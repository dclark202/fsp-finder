<!doctype html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>FSP Finder - Upload</title>
    <link rel="stylesheet" href="https://unpkg.com/sakura.css/css/sakura.css" type="text/css">
    <link rel="stylesheet" href="{{ request.url_for('static', path='style.css') }}">
    <link rel="icon" href="{{ request.url_for('static', path='favicon.png') }}">
</head>
<body>
    <h1>FSP Finder</h1> 
    <h6>AI-powered Foul Speech Pattern detector and automatic music censoring tool</h6>

    <hr>
    <p>
        <b>Thank you</b> for being among the first to try the public release of FSP Finder. 
        If you run into any problems, or have feedback about the tool, please contact us using <a href="{{ request.url_for('contact') }}">this form</a>.
        User feedback is greatly appreciated and will help us build a better program over time.
    </p>

    <h4>How to use this tool</h4> 
    <ul>
      <li>Upload one or more audio files using the box below. Most common audio formats are accepted (e.g., .mp3, .wav, etc.)</li>
      <li>Click the <b>Process audio</b> button to create the transcriptions of the uploaded track(s). You will have a chance to review the edits before applying the censoring</li>
    </ul>
    
   <form action="/analyze" method="post" enctype="multipart/form-data" class="upload-form" novalidate>
      
      <p>Drag & drop your audio files here or click to browse</p>
      
      <input type="file" name="files" id="file-input" required multiple hidden>
      
      <label for="file-input" class="btn-browse">Browse Files</label>

      <div id="file-list-display">
          <p style="color: #585858">No files uploaded yet</p>
      </div>

      <br>
      <button type="submit" class="process-button">Process audio</button>
    </form>
    
      <h4>How it works</h4> 
      <p>This app uses a fine-tuned version of OpenAI's automatic speech recognition model <a href=https://github.com/openai/whisper>Whisper</a> to create lyrics transcripts of the uploaded music files. 
        Always explicit content (e.g., profanity, slurs) is immediately flagged and highlighted in <s>red strikethrough</s> text in the full transcript. 
        The vocals stem of the track is split off from the song using <a href="https://github.com/facebookresearch/demucs">demucs</a> and muted at the corresponding times, creating a high quality edited track, ready for air play.</p>

    <p><b>Please note</b>: By using this tool, you are agreeing to our <a href="{{ request.url_for('terms') }}">Terms of Service</a></p>

    <div id="loading-overlay" class="hidden">
        <div class="loading-box">
            <h2 id="loading-text">Processing...</h2>
            <p>
                Please keep this page open
                
                <br>
                
                This may take several minutes based on song length and number of tracks being processed
            </p>
        </div>
    </div>

    <footer>
        <hr>
        <p>
            &copy; 2025 FSP Finder | 
            <a href="https://github.com/dclark202/auto-censoring">View project on GitHub</a> |
            <a href="{{ request.url_for('contact') }}">Contact us</a>
        </p>
    </footer>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // --- Get references to all the HTML elements ---
            const uploadForm = document.querySelector('.upload-form');
            const fileInput = document.getElementById('file-input');
            const fileListDisplay = document.getElementById('file-list-display');
            const loadingOverlay = document.getElementById('loading-overlay');
            const loadingText = document.getElementById('loading-text');

            // --- Store files in an array to allow removal ---
            let stagedFiles = [];

            // --- Function to update the file list UI ---
            const updateFileList = () => {
                fileListDisplay.innerHTML = ''; // Clear the current list

                if (stagedFiles.length === 0) {
                    fileListDisplay.innerHTML = '<p style="color: #585858">No files uploaded yet</p>';
                    return;
                }

                const list = document.createElement('ul');
                stagedFiles.forEach((file, index) => {
                    const listItem = document.createElement('li');
                    
                    // File name text node
                    const fileName = document.createTextNode(file.name);

                    // Create remove button "x"
                    const removeBtn = document.createElement('button');
                    removeBtn.type = "button"; // prevent form submission
                    removeBtn.className = "remove-file-btn";
                    removeBtn.textContent = 'x';
                    removeBtn.title = `Remove ${file.name}`;
                    
                    // Add click event to remove the file from the array and re-render the list
                    removeBtn.onclick = () => removeFile(index);

                    listItem.appendChild(fileName);
                    listItem.appendChild(removeBtn);
                    list.appendChild(listItem);
                });
                fileListDisplay.appendChild(list);
            };
            
            // --- Helper function to add new files to the staged list ---
            const addFiles = (newFiles) => {
                for (const file of newFiles) {
                    // Optional: check for duplicates before adding
                    if (!stagedFiles.some(f => f.name === file.name && f.size === file.size)) {
                        stagedFiles.push(file);
                    }
                }
                updateFileList();
            };

            // --- Helper function to remove a file by index ---
            const removeFile = (indexToRemove) => {
                stagedFiles.splice(indexToRemove, 1);
                updateFileList();
            };

            // --- EVENT LISTENERS TO UPDATE THE FILE LIST ---
            uploadForm.addEventListener('dragover', (e) => { e.preventDefault(); uploadForm.classList.add('drag-over'); });
            uploadForm.addEventListener('dragleave', () => uploadForm.classList.remove('drag-over'));
            uploadForm.addEventListener('drop', (e) => {
                e.preventDefault();
                uploadForm.classList.remove('drag-over');
                addFiles(e.dataTransfer.files); // Use addFiles helper
            });
            fileInput.addEventListener('change', () => addFiles(fileInput.files)); // Use addFiles helper

            // --- LOGIC FOR SUBMITTING THE FORM AND POLLING FOR RESULTS ---
            uploadForm.addEventListener('submit', (event) => {
                event.preventDefault();
                if (stagedFiles.length === 0) {
                    alert("Please upload at least one audio file.");
                    return;
                }

                loadingText.textContent = 'Uploading...';
                loadingOverlay.classList.remove('hidden');
                
                // Build FormData manually from the stagedFiles array
                const formData = new FormData();
                stagedFiles.forEach(file => {
                    formData.append('files', file);
                });

                fetch('/analyze', {
                    method: 'POST',
                    body: formData
                })
                .then(response => response.json())
                .then(data => {
                    if (data.job_ids && data.job_ids.length > 0) {
                        loadingText.textContent = 'Processing... (0/' + data.job_ids.length + ' complete)';
                        waitForAllJobs(data.job_ids);
                    } else { throw new Error("Server did not return job IDs."); }
                })
                .catch(error => {
                    console.error('Upload Error:', error);
                    loadingOverlay.classList.add('hidden');
                    alert('An error occurred during upload.');
                });
            });

            const waitForAllJobs = (jobIds) => {
                let completedCount = 0;
                let jobStatuses = {}; // Object to track individual job statuses
                jobIds.forEach(id => jobStatuses[id] = 'submitted');

                const updateLoadingText = () => {
                    const processingJobs = Object.values(jobStatuses).filter(s => s === 'processing').length;
                    const queuedJobs = Object.values(jobStatuses).filter(s => s === 'queued').length;

                    if (processingJobs > 0) {
                        loadingText.textContent = `Processing... (${completedCount}/${jobIds.length} complete)`;
                    } else if (queuedJobs > 0) {
                        loadingText.textContent = `Your job is in the queue... (${completedCount}/${jobIds.length} complete)`;
                    } else {
                        loadingText.textContent = `Finalizing... (${completedCount}/${jobIds.length} complete)`;
                    }
                };

                const checkPromises = jobIds.map(jobId => {
                    return new Promise((resolve, reject) => {
                        const interval = setInterval(() => {
                            fetch(`/status/${jobId}`)
                                .then(res => res.json())
                                .then(data => {
                                    jobStatuses[jobId] = data.status; // Update status
                                    updateLoadingText(); // Update UI text

                                    if (data.status === 'complete') {
                                        clearInterval(interval);
                                        completedCount++;
                                        updateLoadingText();
                                        resolve(jobId);
                                    } else if (data.status === 'failed') {
                                        clearInterval(interval);
                                        reject(new Error(`Job ${jobId} failed`));
                                    }
                                });
                        }, 5000); // Check every 5 seconds
                    });
                });

                Promise.all(checkPromises)
                    .then((completedJobIds) => {
                        const jobIdsString = completedJobIds.join(',');
                        window.location.href = `/results?job_ids=${jobIdsString}`;
                    })
                    .catch(error => {
                        console.error("A job failed:", error);
                        loadingOverlay.classList.add('hidden');
                        alert("One or more processing jobs failed. Please check the console and try again.");
                    });
            };
        });
    </script>
</body>
</html>